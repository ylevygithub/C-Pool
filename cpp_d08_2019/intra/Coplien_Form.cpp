/*
Coplien's form, also called canonical form,
is the name given to a type of object that implements a certain set of functions.
These functions let users manipulate objects of that type just like the built-in types.
These functions are the assignment operator,
the copy constructor and the destructor.
They are all the functions that work with an object's life cycle,
and are all involved in resource management,
as we will see in a minute.
In addition to letting users write simple and clear code,
canonical form lets you clearly define the behavior to follow
when manipulating your objects.
Indeed, these functions are all generated automatically by your compiler
if you don't define them,
which can lead to undesired behavior.
Like we saw in the previous video,
it is sometimes necessary to perform deep copy,
which your compiler will not do.
Implementing the functions yourself
lets you clearly specify what should happen when copying your objects.
There's one function in there you haven't heard about yet,
and that's the copy constructor.
A copy constructor is the function that is called
when copying an object of your type, for example:
In both of these cases, we are calling the copy constructor.
Since we haven't implemented it ourselves,
it is automatically generated by the compiler.
Here's how to declare a copy constructor:
*/

#include <iostream>

// class Object {
//     public:
//         Object(const Object &other);
// };

// void func(Object obj) {
// }

// int main() {
//     Object a;
//     Object b(a); //copy ctor.

//     func(a);
// }

/*
Now that you know about copy constructors,
let's create a type in canonical form.
Let's imagine we have an object managing a pointer to an int,
called "SmartPointer".
It will automatically allocate and release memory for the pointer.
For now, our class simply allocates memory for an int
and initializes it with a 0.
A "value" function lets us get and modify the value of the pointer.
Finally, our destructor releases the memory for the pointer.
Let's write a little main function to test our class:
This all works well.
*/
class SmartPointer {
    public:
        SmartPointer()
            : _ptr(new int(0))
        {}

        ~SmartPointer() { delete _ptr; }

        int &value() { return (*_ptr); }

    private:
        int *_ptr;
};

int main() {
    SmartPointer ptr;
    ptr.value() = 42;
    std::cout << ptr.value() << std::endl;
}
//output = 42


/*
Let's now try copying our object:
If we compile and run, we now get a runtime error.
*/

class SmartPointer {
    public:
        SmartPointer()
            : _ptr(new int(0))
        {}

        ~SmartPointer() { delete _ptr; }

        int &value() { return (*_ptr); }

    private:
        int *_ptr;
};

int main() {
    SmartPointer ptr;
    ptr.value() = 42;
    std::cout << ptr.value() << std::endl;

    SmartPointer copy(ptr);
}

/*
Yet again, we forgot deep copy,
Nothing too complicated.
If we now try to compile and run, it all works as expected.
By implementing these three functions
(copy constructor, assignment operator and destructor),
we've clearly defined our object's life cycle
and its resource management behavior.
Coplien's form isn't necessary for all classes,
but when a class performs memory management, it's very important.
Be smart: whenever you create a class,
ask yourself whether it should be canonical or not.
*/

class SmartPointer {
    public:
        SmartPointer()
            : _ptr(new int(0))
        {}

        ~SmartPointer() { delete _ptr; }

        SmartPointer(const SmartPointer &other)
            : _ptr(new int(other.value()))
        {}

        SmartPointer &operator=(const SmartPointer &rhs) { 
            if (this == &rhs)
                return (*this);
            if (_ptr)
                delete _ptr;
            _ptr = new int(rhs.value());
            return (*this);
        }

        int &value() { return (*_ptr); }
        const int &value() const { return (*_ptr);}

    private:
        int *_ptr;
};

int main() {
    SmartPointer ptr;
    ptr.value() = 42;
    std::cout << ptr.value() << std::endl;

    SmartPointer copy(ptr);
}
